## 过河卒（C++）

编程题

### 题目描述：

棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，A 点 (0,0)、B 点 (n,m)，同样马的位置坐标是需要给出的。

![AG0FTDB7SP45.png](https://nuc.alphacoding.cn/api/resource/v2/exercises/660283181e3ba52ba46f868e/f/HR5GSU1KJ2ZM)

现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

### 输入格式：

一行四个正整数，分别表示 B 点坐标和马的坐标。

### 输出格式：

一个整数，表示所有的路径条数。

### 数据范围：

1≤n,m≤20，0≤ 马的坐标 ≤20。

### 输入样例：

```
6 6 3 3
```

### 输出样例：

```
6
```

任务与要求

运行程序，使其通过所有检查

# 题解
```c++
#include <stdio.h>
#include <algorithm>

using namespace std;

int a[30][30];
long long f[30][30];

int main() {
	int x1, y1, x2, y2;
	scanf("%d %d %d %d", &x1, &y1, &x2, &y2);
	x1 += 2, y1 += 2, x2 += 2, y2 += 2; //从(2,2)开始到(n+2,m+2)结束

	for (int i = 0; i <= x1; i++) {
		for (int j = 0; j <= y1; j++) {
			a[i][j] = 1;
		}
	}

	a[x2][y2] = 0;
	a[x2 - 2][y2 - 1] = a[x2 - 2][y2 + 1] = a[x2 - 1][y2 - 2] = a[x2 - 1][y2 + 2] = 0;
	a[x2 + 2][y2 - 1] = a[x2 + 2][y2 + 1] = a[x2 + 1][y2 - 2] = a[x2 + 1][y2 + 2] = 0;


	f[2][1] = 1;
	for (int i = 2; i <= x1; i++) {
		for (int j = 2; j <= y1; j++) {
			if (a[i][j]) {
				f[i][j] = f[i][j - 1] + f[i - 1][j];
			}
		}
	}

	printf("%lld", f[x1][y1]);
	return 0;
}
```