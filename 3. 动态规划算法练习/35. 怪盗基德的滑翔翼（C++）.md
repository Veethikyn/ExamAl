## 怪盗基德的滑翔翼（C++）

编程题

### 题目描述：

假设城市中一共有N幢建筑排成一条线，每幢建筑的高度各不相同。

初始时，怪盗基德可以在任何一幢建筑的顶端。

他可以选择一个方向逃跑，但是不能中途改变方向（因为中森警部会在后面追击）。

因为滑翔翼动力装置受损，他只能往下滑行（即：只能从较高的建筑滑翔到较低的建筑）。

他希望尽可能多地经过不同建筑的顶部，这样可以减缓下降时的冲击力，减少受伤的可能性。

请问，他最多可以经过多少幢不同建筑的顶部(包含初始时的建筑)？

### 输入格式：

输入数据第一行是一个整数K，代表有K组测试数据。

每组测试数据包含两行：第一行是一个整数N，代表有N幢建筑。第二行包含N个不同的整数，每一个对应一幢建筑的高度h，按照建筑的排列顺序给出。

### 输出格式：

对于每一组测试数据，输出一行，包含一个整数，代表怪盗基德最多可以经过的建筑数量。

### 数据范围：

1≤K≤100, 1≤N≤100, 0<h<10000

### 输入样例：

```
3
8
300 207 155 299 298 170 158 65
8
65 158 170 298 299 155 207 300
10
2 1 3 4 5 6 7 8 9 10
```

### 输出样例：

```
6
6
9
```

任务与要求

运行程序，使其通过所有检查

# 题解
```c++
#include <stdio.h>
#include <algorithm>
#include <string.h>

using namespace std;

int a[110];
int f[110];

int main(){
    int n,t;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",&a[i]);
        }
        int ans=1;
        for(int i=1;i<=n;i++){
            f[i]=1;
            for(int j=1;j<=i;j++){
                if(a[j]>a[i]){
                    f[i]=max(f[i],f[j]+1);
                }
            }
            ans=max(ans,f[i]);
        }

        memset(f, 0, sizeof f);
        for(int i=n;i>=1;i--){
            f[i]=1;
            for(int j=n;j>=i;j--){
                if(a[j]>a[i]){
                    f[i]=max(f[i],f[j]+1);
                }
            }
            ans=max(ans,f[i]);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```