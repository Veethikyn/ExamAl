## 拦截导弹（C++）

编程题

### 题目描述：

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。

但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

某天，雷达捕捉到敌国的导弹来袭。

由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

### 输入格式：

共一行，输入导弹依次飞来的高度。

### 输出格式：

第一行包含一个整数，表示最多能拦截的导弹数。

第二行包含一个整数，表示要拦截所有导弹最少要配备的系统数。

### 数据范围：

雷达给出的高度数据是不大于 30000的正整数，导弹数不超过 1000。

### 输入样例：

```
389 207 155 300 299 170 158 65
```

### 输出样例：

```
6
2
```

任务与要求

运行程序，使其通过所有检查

# 题解
```c++
#include <stdio.h>
#include <algorithm>

using namespace std;

int a[1010];
int f[1010],g[1010];

int n=0;

int main(){
    while(~scanf("%d",&a[n])){
        n++;
    }

    int ans=1;
    for(int i=0;i<n;i++){
        f[i]=1;
        for(int j=0;j<i;j++){
            if(a[j]>=a[i]){
                f[i]=max(f[i],f[j]+1);
            }
        }
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);

    int cnt=0;
    for(int i=0;i<n;i++){
        int k=0; //k用于扫描现有序列结尾
        while(k<=cnt&&g[k]<a[i]){
            k++; //新建拦截系统（序列）
        }
        g[k]=a[i]; //更新序列结尾
        if(k>cnt){
            cnt++;
        }
    }
    printf("%d",cnt);
    return 0;
}
```